#include "main.h"
#include "stm32f4xx_conf.h"
//#include "lcd_5110.h"
#include "helperFunctionsLib.h"
#include <stdio.h>




/* DANIEL FUNCTIONS */
/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx_conf.h"
#include "stm32f4xx_gpio.h"
#include "stm32f4xx_rcc.h"
#include "stm32f4xx_syscfg.h" //odpowiedzialna za zdefiniowanie nazw pinów dla kontrolera przerwañ
#include "stm32f4xx_adc.h"
#include "math.h"
/* Calibration define ------------------------------------------------------------*/
#define RL_VALUE_MQ3                 (100.0)  //define the load resistance on the board, in kilo ohms
#define RO_CLEAN_AIR_FACTOR_MQ3      (60.314) //RO_CLEAR_AIR_FACTOR=(Sensor resistance in clean air)/RO,
                                                      //which is derived from the chart in datasheet
#define CALIBARAION_SAMPLE_TIMES     (5.0)    //define how many samples you are going to take in the calibration phase
#define CALIBRATION_SAMPLE_INTERVAL  (500)   //define the time interal(in milisecond) between each samples in the
                                                     //cablibration phase
#define READ_SAMPLE_INTERVAL         (50)    //define how many samples you are going to take in normal operation
#define READ_SAMPLE_TIMES            (5.0)     //define the time interal(in milisecond) between each samples in
                                                     //normal operation
/*****************************Globals***********************************************/
float ADC_Result = 0;
float Ro = 10;
float mgL;
/*******************************************************************************
 *
 */
//void ADCInit()
//{
//	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA , ENABLE); // zegar dla portu GPIO z którego wykorzystany zostanie pin jako wejœcie ADC (PA1)
//	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE); // zegar dla modu³u ADC1
//
//	GPIO_InitTypeDef GPIO_InitStructure;
//	//inicjalizacja wejœcia ADC
//	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
//	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
//	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
//	GPIO_Init(GPIOA, &GPIO_InitStructure);
//
//	ADC_CommonInitTypeDef ADC_CommonInitStructure;
//	// niezale¿ny tryb pracy przetworników
//	ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
//	// zegar g³ówny podzielony przez 2
//	ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
//	// opcja istotna tylko dla trybu multi ADC
//	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
//	// czas przerwy pomiêdzy kolejnymi konwersjami
//	ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
//	ADC_CommonInit(&ADC_CommonInitStructure);
//
//
//	ADC_InitTypeDef ADC_InitStructure;
//	//ustawienie rozdzielczoœci przetwornika na maksymaln¹ (12 bitów)
//	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
//	//wy³¹czenie trybu skanowania (odczytywaæ bêdziemy jedno wejœcie ADC
//	//w trybie skanowania automatycznie wykonywana jest konwersja na wielu //wejœciach/kana³ach)
//	ADC_InitStructure.ADC_ScanConvMode = DISABLE;
//	//w³¹czenie ci¹g³ego trybu pracy
//	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
//	//wy³¹czenie zewnêtrznego wyzwalania
//	//konwersja mo¿e byæ wyzwalana timerem, stanem wejœcia itd. (szczegó³y w //dokumentacji)
//	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
//	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
//	//wartoœæ binarna wyniku bêdzie podawana z wyrównaniem do prawej
//	//funkcja do odczytu stanu przetwornika ADC zwraca wartoœæ 16-bitow¹
//	//dla przyk³adu, wartoœæ 0xFF wyrównana w prawo to 0x00FF, w lewo 0x0FF0
//	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
//	//liczba konwersji równa 1, bo 1 kana³
//	ADC_InitStructure.ADC_NbrOfConversion = 1;
//	// zapisz wype³nion¹ strukturê do rejestrów przetwornika numer 1
//	ADC_Init(ADC1, &ADC_InitStructure);
//
//	/* KONFIGURACJA KANALOW ADC	*/
//	ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 1, ADC_SampleTime_84Cycles);
//
//	/*-------------------------*/
//
//	ADC_Cmd(ADC1, ENABLE);
//}
/****************** Delay ****************************************
Input:   ms - number of milliseconds
Output:  delay
************************************************************************************/
void delay(uint32_t ms)
{
	uint32_t iter = 0;
	uint32_t sysTime;
	sysTime = ms*14000;

	for (iter=0;iter<sysTime;iter++);
}

//void diodeDiscoveryInit()
//{
//	/* GPIOD Periph clock enable */
//	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);
//
//	GPIO_InitTypeDef  GPIO_InitStructure;
//	/* Configure PD12(GREEN), PD13(ORANGE), PD14(RED) and PD15(BLUE) in output pushpull mode */
//	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13| GPIO_Pin_14| GPIO_Pin_15;
//	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
//	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
//	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
//	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
//	GPIO_Init(GPIOD, &GPIO_InitStructure);
//}

float analogRead()
{
	float ADC_Result = 0;
	float MQResistance;

	/*Odczyt wartoœci poprzez odpytywanie flagi zakoñczenia konwersji: */
	ADC_SoftwareStartConv(ADC1);
	while(ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);
	ADC_Result = ADC_GetConversionValue(ADC1);
	/*------------------------------------------------------------*/
	//ADCvolt = (ADC_Result*4.95)/4095;	// 4095 BO 12 BIT ROZDZIELCZOSC ADC(NIE ZMIENIAC!!)

	MQResistance = ( ((double)RL_VALUE_MQ3*(4095-ADC_Result)/ADC_Result));

	return MQResistance;
}
/*******************************************************************************
* OTHER FUNCTIONS
*******************************************************************************/
/***************************** MQCalibration ****************************************
Input:   None
Output:  Ro of the sensor
Remarks: This function assumes that the sensor is in clean air. It use
         MQResistanceCalculation to calculates the sensor resistance in clean air
         and then divides it with RO_CLEAN_AIR_FACTOR. RO_CLEAN_AIR_FACTOR is about
         10, which differs slightly between different sensors.
************************************************************************************/
float MQCalibration()
{
	uint32_t i;
	float RS_AIR_val=0;
	float r0;

	for (i=0;i<CALIBARAION_SAMPLE_TIMES;i++)
	{
		RS_AIR_val += analogRead();
		delay(CALIBRATION_SAMPLE_INTERVAL);
	}

	RS_AIR_val = RS_AIR_val/CALIBARAION_SAMPLE_TIMES;              //calculate the average value

	r0 = RS_AIR_val/RO_CLEAN_AIR_FACTOR_MQ3;                      //RS_AIR_val divided by RO_CLEAN_AIR_FACTOR yields the Ro
                                                         	 	//according to the chart in the datasheet
	return r0;
}
/*****************************  MQRead *********************************************
Input:   None
Output:  Rs of the sensor
Remarks: This function use MQResistanceCalculation to calculate the sensor resistance (Rs).
         The Rs changes as the sensor is in the different concentration of the target
         gas. The sample times and the time interval between samples could be configured
         by changing the definition of the macros.
************************************************************************************/
float MQRead()
{
	uint32_t i;
	float rs=0;

	for (i=0;i<READ_SAMPLE_TIMES;i++)
	{
		rs += analogRead();
		delay(READ_SAMPLE_INTERVAL);
	}
	rs = rs/READ_SAMPLE_TIMES;

	return rs;
}
/*****************************  MQGetGasPercentage **********************************
Input:   rs_ro_ratio - Rs divided by Ro
Output:  mg/L of the target gas
Remarks: This function uses different equations representing curves of each gas to
         calculate the mg/L (milligrams per liter) of the target gas.
************************************************************************************/
float MQGetGasPercentage(float rs_ro_ratio)
{
    return (pow(10,((-1.487*(log10(rs_ro_ratio))) - 0.401)));
}

//**********************************************************
//-----------------------------------------------------------
//**********************************************************



//const unsigned char probaHours [] = {
//0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
//0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x3C, 0x03, 0x00, 0x3E, 0x22,
//0x22, 0x3E, 0x00, 0x00, 0x3E, 0x20, 0x20, 0x3E, 0x00, 0x00, 0x03, 0x00, 0x3F, 0x00, 0x00, 0x3F,
//0x00, 0x00, 0x00, 0x00, 0x3F, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x1C, 0x2A, 0x2A, 0x2C, 0x00, 0x00,
//0x00, 0x00, 0x3A, 0x2A, 0x2A, 0x3E, 0x00, 0x00, 0x3F, 0x22, 0x22, 0x1C, 0x00, 0x00, 0x3F, 0x00,
//0x00, 0x1C, 0x2A, 0x2A, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE0, 0x40,
//0x00, 0x00, 0xC0, 0x40, 0x40, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0xF0, 0x00, 0x00,
//0xC0, 0x40, 0x40, 0x00, 0xD0, 0x00, 0x40, 0x80, 0x00, 0x00, 0xC0, 0x00, 0x80, 0x40, 0x40, 0x80,
//0x00, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0xC0, 0x40, 0x40, 0xC0, 0x00, 0x00, 0x40, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x07, 0x04, 0x00, 0x00, 0x07, 0x04, 0x04, 0x07, 0x00, 0x00, 0x00, 0x00, 0x03, 0x04,
//0x04, 0x07, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x01, 0x06, 0x06, 0x01, 0x00,
//0x03, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x07, 0x00, 0x00, 0x07, 0x00,
//0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//};




const unsigned char shapes [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x80, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xF0, 0x30, 0x30, 0x30, 0x30,
0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFF, 0x0F, 0xFF, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x38, 0xFC, 0xCE, 0x07, 0x03, 0x03, 0x06, 0x0E, 0x0C, 0x06, 0x06, 0x07, 0x01,
0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x07, 0x06, 0x0C, 0x0E, 0x06, 0x07, 0x03, 0x07, 0xCE, 0xFC,
0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xE0, 0xE0,
0xE0, 0xE0, 0xE0, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x1F, 0x0F, 0x00, 0x00, 0x00, 0x0F, 0x1F,
0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0,
0xC0, 0x00, 0x00, 0xF0, 0xF0, 0x18, 0x18, 0x18, 0x0E, 0x0F, 0x01, 0x00, 0x00, 0x00, 0xC0, 0xF8,
0x3C, 0x0E, 0x07, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x0E, 0x3C, 0xF8, 0xC0, 0x00, 0x00,
0x00, 0x01, 0x0F, 0x0E, 0x18, 0x18, 0x18, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03, 0x06, 0x7E, 0xFC, 0xC0,
0x00, 0xC0, 0xFC, 0x7E, 0x06, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x06, 0x0C, 0x0C, 0xBC, 0xF8, 0x40, 0x00,
0x00, 0x00, 0x01, 0x0F, 0x1E, 0x38, 0x70, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x70, 0x38, 0x1E,
0x0F, 0x01, 0x00, 0x00, 0x00, 0x40, 0xF8, 0xBC, 0x0C, 0x0C, 0x06, 0x07, 0x07, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x07, 0x7F, 0xF8, 0x7F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0E,
0x1F, 0x39, 0x70, 0x60, 0x70, 0x30, 0x38, 0x18, 0x30, 0x70, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00,
0xC0, 0xF0, 0x70, 0x30, 0x18, 0x18, 0x30, 0x70, 0x60, 0x70, 0x39, 0x1F, 0x0F, 0x04, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07,
0x06, 0x06, 0x06, 0x06, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const unsigned char logo_mini_mono [] = {
0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0x7F, 0x7F, 0x7F, 0xFF, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFE, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x7F, 0x3F, 0x0F, 0x03, 0x00, 0x00, 0x00, 0x80, 0xE0, 0x01, 0x01, 0x02, 0x00, 0x04, 0x08, 0xF8,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8,
0xF8, 0xF9, 0xFB, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0x7F, 0x1F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x03, 0x00, 0x00, 0x00, 0x00,
0x00, 0xE0, 0x0C, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x03, 0x03,
0x03, 0x81, 0x81, 0x81, 0xC1, 0xC0, 0xC0, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x3E, 0xFF, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE,
0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xFC,
0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F,
};



float printFloatAdcValue(){

	LCD5110_set_XY(4,4);
	char buffer[64];
	mgL = MQGetGasPercentage(analogRead()/Ro);//	(mg/L)
//	if((mgL*2.1) > 8.6)
//		mgL = 4.09;
	int ret = snprintf(buffer, sizeof buffer, "%.5f", mgL*2.1);

	LCD5110_write_string(buffer);
	//LCD5110_write_string("pizda");
	float floatValuePerMil = (roundf(mgL*100) / 100)*2.1;

	return floatValuePerMil;
}

//float adc1Value;
int afterCalibration = 0;
float alcocholLevelPerMil = 0;
int main(void)
{
  SystemInit();

  // Initialization of Nokia 5110 display
  LCD5110_init();
  //*******************************
  ADCInit();

  //Initialization of GPIO ports
  	GPIO_InitTypeDef GPIO_InitStructure;
  	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
  	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
  	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
  	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
  	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
  	GPIO_Init(GPIOA, &GPIO_InitStructure);




    //****************************




  setTimer();
  //adc1Init();





//  LCD5110_write_img(logo_mini_mono, sizeof(logo_mini_mono));
  	LCD5110_clear();

  	int counter = 0;

  breathAlyzerLogoShow();
  for(;;){
	  if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_3) == 0){
		  while(counter < 10){
		  //	  unsigned int counter = TIM3->CNT;

	  	  	  if(TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)
	  	  	  {
		  	  	  if(counter < 10){
			  	  	  heatUpProgress(counter);
			  	  	  counter++;
		  	  	  }


		  	  // wyzerowanie flagi wyzwolonego przerwania
		  	  TIM_ClearITPendingBit(TIM3, TIM_IT_Update);

	  	  	  }




  	  	  }
		  break;
	  }
  }
  if(afterCalibration == 0){
	  Ro = MQCalibration();	//kalibracja
	  afterCalibration = 69;
  }
  waitingScreenShow();


counter = 0;


for(;;){
	if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_3) == 0){
		for(;;){

		bloodAlcLevelShow();

		for(;;){


			if(counter < 10)
			  {

				  alcocholLevelPerMil = printFloatAdcValue(Ro);  //W alcoholLevelPerMil znajduje siê liczba promil
				  if(TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)
				  {


						  counter++;



				    // wyzerowanie flagi wyzwolonego przerwania
				  	TIM_ClearITPendingBit(TIM3, TIM_IT_Update);

				  }
			  }
			if(counter == 10){
				howLongToDrive(alcocholLevelPerMil);
				counter++;
			}

			//mgL = MQGetGasPercentage(MQRead()/Ro);//	(mg/L)

			if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_3) == 0){
				counter = 0;
				break;
		}


		}
	}
	}

}





















}
